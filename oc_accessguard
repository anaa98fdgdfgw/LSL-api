/*
    OpenCollar Plugin · GuardGender (Corrade Attachment Scanner)
    ----------------------------------------------------
    GPL-v2 - https://github.com/OpenCollarTeam/OpenCollar
    
    This script connects to Corrade to scan avatars'
    attachments and detect gender using getobjectdata command.
    Memory-secured version with leak prevention.
    
    Last Updated: 2025-07-01 14:54:12
    Login: anaa98fdgdfgw
*/

//----------------------------------------
// CONFIGURATION
//----------------------------------------
string PARENT_MENU = "Apps";
string MAIN_MENU   = "GuardGender";
string CORRADE_URL = "http://corrade.sl-anais-kiyori.cloud/";
string CORRADE_GROUP = "anais_bots";
string CORRADE_PASS = "5e0d5686903ab84260e4650cba96d2a8d70f0ef3";
string CORRADE_USERNAME = "anaa98fdgdfgw";
string CORRADE_BOTNAME = "nucleus";
string HOME_URL = "http://maps.secondlife.com/secondlife/Backdrop City/123/113/22";

// DÉLAIS POUR LA STABILISATION
float TELEPORT_STABILIZATION_DELAY = 5.0;  // Délai après téléportation
float SCAN_RETRY_DELAY = 3.0;              // Délai entre les retry

//----------------------------------------
// MEMORY SECURITY CONSTANTS
//----------------------------------------
integer MAX_LIST_SIZE = 50;        // Limite maximale pour toute liste
integer MAX_STRING_LENGTH = 500;   // Limite pour les strings longs
integer MEMORY_CLEANUP_INTERVAL = 300; // Nettoyage automatique toutes les 5 minutes
float LAST_MEMORY_CLEANUP = 0.0;   // Timestamp du dernier nettoyage

//----------------------------------------
// GENDER DETECTION CONFIGURATION - Séparé pour réduire la taille des listes en mémoire
//----------------------------------------
list FEMALE_BODY_KEYWORDS;  // Initialisé plus tard pour économiser la mémoire
list MALE_BODY_KEYWORDS;    // Initialisé plus tard pour économiser la mémoire

//----------------------------------------
// OPEN COLLAR CONSTANTS
//----------------------------------------
integer MENUNAME_REQUEST  = 3000;
integer MENUNAME_RESPONSE = 3001;
integer MENUNAME_REMOVE   = 3003;
integer CMD_OWNER = 500;
integer CMD_WEARER = 503;
integer LM_SETTING_SAVE = 2000;
integer LM_SETTING_REQUEST = 2001;
integer LM_SETTING_RESPONSE = 2002;
integer LM_SETTING_DELETE = 2003;

integer DIALOG_TIMEOUT    = 30;
integer MAX_BUTTON_LEN    = 24;
integer AVATARS_PER_PAGE  = 9;
integer SCAN_RANGE        = 100;
integer HTTP_TIMEOUT      = 10; // Timeout pour les requêtes HTTP

// Debug mode
integer g_iDebug = TRUE;

//----------------------------------------
// INTERNAL STATE
//----------------------------------------
integer g_iMenuChan;
integer g_iMenuListen;
integer g_iMenuHandle;
key     g_kTarget;
key     g_kRequestID;
key     g_kUserID;
list    g_lTargetKeys;    // Ne sera rempli que lors d'un scan
integer g_iTestingBot;
integer g_iConfiguring;
string  g_sConfigItem;
integer g_iGuardianActive = FALSE;
integer g_iCurrentPage = 0;
string  g_sCurrentMenu = "";
string  g_sLastCommand = "";
integer g_iSendHomeAfterScan = TRUE;
integer g_iScanAttempts = 0;
integer g_iMaxRetries = 3;
integer g_iBotTeleporting = FALSE; // Flag pour indiquer si le bot est en cours de téléportation
integer g_iWaitingForStabilization = FALSE; // Flag pour attendre la stabilisation du bot

//----------------------------------------
// MEMORY SECURITY FUNCTIONS
//----------------------------------------

// Fonction pour vérifier et nettoyer les listes si elles deviennent trop grandes
list SecureList(list inputList, string listName) {
    integer listLength = llGetListLength(inputList);
    if(listLength > MAX_LIST_SIZE) {
        Debug("WARNING: List " + listName + " exceeded max size (" + (string)listLength + "), truncating to " + (string)MAX_LIST_SIZE);
        list result = llList2List(inputList, 0, MAX_LIST_SIZE - 1);
        return result;
    }
    return inputList;
}

// Fonction pour vérifier et tronquer les strings trop longs
string SecureString(string inputString, string stringName) {
    integer stringLength = llStringLength(inputString);
    if(stringLength > MAX_STRING_LENGTH) {
        Debug("WARNING: String " + stringName + " exceeded max length (" + (string)stringLength + "), truncating");
        return llGetSubString(inputString, 0, MAX_STRING_LENGTH - 1);
    }
    return inputString;
}

// Nettoyage automatique de la mémoire
PerformMemoryCleanup() {
    Debug("Performing automatic memory cleanup");
    
    // Nettoyer les listes globales si elles sont trop grandes
    if(llGetListLength(g_lTargetKeys) > MAX_LIST_SIZE) {
        g_lTargetKeys = [];
        Debug("Cleared oversized g_lTargetKeys");
    }
    
    // Nettoyer les listes de mots-clés si elles existent et sont trop grandes
    if(llGetListLength(FEMALE_BODY_KEYWORDS) > 0) {
        FEMALE_BODY_KEYWORDS = SecureList(FEMALE_BODY_KEYWORDS, "FEMALE_BODY_KEYWORDS");
    }
    if(llGetListLength(MALE_BODY_KEYWORDS) > 0) {
        MALE_BODY_KEYWORDS = SecureList(MALE_BODY_KEYWORDS, "MALE_BODY_KEYWORDS");
    }
    
    // Réinitialiser les variables de menu si nécessaire
    if(g_sCurrentMenu == "" && g_iMenuHandle == 0) {
        g_iCurrentPage = 0;
        g_sConfigItem = "";
    }
    
    LAST_MEMORY_CLEANUP = llGetTime();
    Debug("Memory cleanup completed");
}

// Vérification automatique de la mémoire
CheckMemoryUsage() {
    if(llGetTime() - LAST_MEMORY_CLEANUP > MEMORY_CLEANUP_INTERVAL) {
        PerformMemoryCleanup();
    }
}

//----------------------------------------
// UTILITY FUNCTIONS
//----------------------------------------
Debug(string sMsg) { 
    if(g_iDebug) {
        // Sécuriser la longueur du message de debug
        sMsg = SecureString(sMsg, "debug_message");
        llOwnerSay("[DEBUG] " + sMsg);
    }
}

string TruncateName(string sName, integer iMaxLen) {
    if(llStringLength(sName) <= iMaxLen) return sName;
    return llGetSubString(sName, 0, iMaxLen - 3) + "..";
}

// Fonction corrigée pour encoder les paramètres URL avec sécurité mémoire
string wasKeyValueEncode(list params) {
    // Sécuriser la liste d'entrée
    params = SecureList(params, "wasKeyValueEncode_params");
    
    string wasString = ""; 
    integer i;
    integer paramLength = llGetListLength(params);
    for(i = 0; i < paramLength; i += 2) {
        if(i > 0) wasString += "&";
        string paramKey = llList2String(params, i);
        string paramValue = llList2String(params, i+1);
        
        // Sécuriser les paramètres individuels
        paramKey = SecureString(paramKey, "param_key");
        paramValue = SecureString(paramValue, "param_value");
        
        wasString += llEscapeURL(paramKey) + "=" + llEscapeURL(paramValue);
        
        // Vérifier la longueur totale
        if(llStringLength(wasString) > MAX_STRING_LENGTH) {
            Debug("WARNING: wasKeyValueEncode result getting too long, stopping");
            break;
        }
    }
    
    // Libération sécurisée
    params = [];
    return SecureString(wasString, "wasKeyValueEncode_result");
}

string wasListToCSV(list items) {
    // Sécuriser la liste d'entrée
    items = SecureList(items, "wasListToCSV_items");
    
    string csvString = "";
    integer i;
    integer itemLength = llGetListLength(items);
    for(i = 0; i < itemLength; i++) {
        if(i > 0) csvString += ",";
        string item = llList2String(items, i);
        item = SecureString(item, "csv_item");
        csvString += item;
        
        // Vérifier la longueur totale
        if(llStringLength(csvString) > MAX_STRING_LENGTH) {
            Debug("WARNING: CSV string getting too long, truncating");
            break;
        }
    }
    
    // Libération sécurisée
    items = [];
    return SecureString(csvString, "csv_result");
}

// Fonction pour extraire une valeur d'une réponse HTTP avec sécurité mémoire
string GetValueFromResponse(string body, string keyName) {
    // Sécuriser les paramètres d'entrée
    body = SecureString(body, "response_body");
    keyName = SecureString(keyName, "key_name");
    
    // Recherche du paramètre dans le format key=value
    list pairs = llParseString2List(body, ["&"], []);
    pairs = SecureList(pairs, "response_pairs");
    
    integer i;
    integer pairLength = llGetListLength(pairs);
    for(i = 0; i < pairLength; i++) {
        string pair = llList2String(pairs, i);
        list keyValue = llParseString2List(pair, ["="], []);
        
        if(llGetListLength(keyValue) >= 2) {
            string paramKey = llUnescapeURL(llList2String(keyValue, 0));
            if(paramKey == keyName) {
                string paramValue = llUnescapeURL(llList2String(keyValue, 1));
                paramValue = SecureString(paramValue, "response_value");
                
                // Libération sécurisée
                pairs = [];
                keyValue = [];
                return paramValue;
            }
        }
        
        // Libération progressive
        keyValue = [];
    }
    
    // Libération finale
    pairs = [];
    return "";
}

// Chargement à la demande des mots-clés avec sécurité mémoire
InitializeGenderKeywords() {
    // On n'initialise les listes que lorsqu'elles sont nécessaires
    if(llGetListLength(FEMALE_BODY_KEYWORDS) == 0) {
        FEMALE_BODY_KEYWORDS = [
            "maitreya", "lara", "legacy", "perky", "freya", "isis", "venus", "meshbody",
            "hourglass", "physique", "ebody", "tmp", "slink female", "reborn", "kupra"
        ];
        FEMALE_BODY_KEYWORDS = SecureList(FEMALE_BODY_KEYWORDS, "FEMALE_BODY_KEYWORDS");
    }
    
    if(llGetListLength(MALE_BODY_KEYWORDS) == 0) {
        MALE_BODY_KEYWORDS = [
            "gianni", "jake", "geralt", "slink male", "signature", "adam", "belleza",
            "aesthetic", "david", "onupup", "tmp male", "legacy male", "meshbody m"
        ];
        MALE_BODY_KEYWORDS = SecureList(MALE_BODY_KEYWORDS, "MALE_BODY_KEYWORDS");
    }
}

string DetectGenderFromBody(list attachments) {
    // Sécuriser la liste d'attachments
    attachments = SecureList(attachments, "attachments");
    
    // Chargement à la demande des mots-clés pour économiser de la mémoire
    InitializeGenderKeywords();
    
    integer i;
    integer j;
    integer attachCount = llGetListLength(attachments);
    integer femaleCount = llGetListLength(FEMALE_BODY_KEYWORDS);
    integer maleCount = llGetListLength(MALE_BODY_KEYWORDS);
    
    for(i = 0; i < attachCount; i++) {
        string item = llToLower(llList2String(attachments, i));
        item = SecureString(item, "attachment_item");
        
        // Vérifier les mots-clés féminins
        for(j = 0; j < femaleCount; j++) {
            string keyword = llList2String(FEMALE_BODY_KEYWORDS, j);
            if(~llSubStringIndex(item, keyword)) {
                // Libération avant retour
                attachments = [];
                return "female";
            }
        }
        
        // Vérifier les mots-clés masculins
        for(j = 0; j < maleCount; j++) {
            string keyword = llList2String(MALE_BODY_KEYWORDS, j);
            if(~llSubStringIndex(item, keyword)) {
                // Libération avant retour
                attachments = [];
                return "male";
            }
        }
    }
    
    // Libération finale
    attachments = [];
    return "unknown";
}

// FONCTION pour traiter les données d'attachements avec getobjectdata + sécurité mémoire
list ProcessAttachmentData(string body) {
    Debug("Processing attachment data from getobjectdata");
    
    // Sécuriser le body
    body = SecureString(body, "attachment_data_body");
    
    string success = GetValueFromResponse(body, "success");
    if(success != "True" && success != "true") {
        string error = GetValueFromResponse(body, "error");
        Debug("Corrade getobjectdata failed: " + error);
        return [];
    }
    
    string dataContent = GetValueFromResponse(body, "data");
    if(dataContent == "") {
        Debug("No data field found in getobjectdata response");
        return [];
    }
    
    dataContent = SecureString(dataContent, "data_content");
    Debug("Raw attachment data: " + llGetSubString(dataContent, 0, 300) + "...");
    
    list results = [];
    list dataLines = llParseString2List(dataContent, ["\n"], []);
    dataLines = SecureList(dataLines, "data_lines");
    
    integer i;
    integer lineCount = llGetListLength(dataLines);
    for(i = 0; i < lineCount; i++) {
        string line = llList2String(dataLines, i);
        if(line != "") {
            list parts = llParseString2List(line, [","], []);
            
            if(llGetListLength(parts) >= 2) {
                string attachPoint = llList2String(parts, 0);
                string objectName = llList2String(parts, 1);
                
                // Sécuriser les données extraites
                attachPoint = SecureString(attachPoint, "attach_point");
                objectName = SecureString(objectName, "object_name");
                
                // Vérifier si c'est un attachement valide
                if(attachPoint != "" && objectName != "" && attachPoint != "None") {
                    results += [objectName];
                    Debug("Found attachment: " + objectName + " on " + attachPoint);
                    
                    // Sécuriser la taille de la liste résultat
                    if(llGetListLength(results) >= MAX_LIST_SIZE) {
                        Debug("WARNING: Results list reached maximum size, stopping processing");
                        break;
                    }
                }
            }
            
            // Libération progressive
            parts = [];
        }
    }
    
    // Libération finale
    dataLines = [];
    results = SecureList(results, "attachment_results");
    
    Debug("Extracted " + (string)llGetListLength(results) + " attachments");
    return results;
}

// FONCTION CORRIGÉE POUR PARSER LES SLURLS AVEC URL ENCODING + sécurité mémoire
list ParseSLurl(string slurl) {
    Debug("Parsing SLurl: " + slurl);
    
    // Sécuriser l'URL d'entrée
    slurl = SecureString(slurl, "input_slurl");
    
    // Décoder l'URL d'abord (convertir %20 en espaces, etc.)
    string decodedUrl = llUnescapeURL(slurl);
    decodedUrl = SecureString(decodedUrl, "decoded_url");
    Debug("Decoded URL: " + decodedUrl);
    
    integer start = llSubStringIndex(decodedUrl, "secondlife/") + 11;
    if(start < 11) {
        Debug("Invalid SLurl format - no 'secondlife/' found");
        return [];
    }
    
    string remainder = llGetSubString(decodedUrl, start, -1);
    remainder = SecureString(remainder, "slurl_remainder");
    Debug("SLurl remainder: " + remainder);
    
    list parts = llParseString2List(remainder, ["/"], []);
    parts = SecureList(parts, "slurl_parts");
    Debug("SLurl parts count: " + (string)llGetListLength(parts));
    
    if(llGetListLength(parts) >= 4) {
        string region = llList2String(parts, 0);
        float x = (float)llList2String(parts, 1);
        float y = (float)llList2String(parts, 2);
        float z = (float)llList2String(parts, 3);
        
        region = SecureString(region, "parsed_region");
        Debug("Parsed region: '" + region + "', coords: " + (string)x + "," + (string)y + "," + (string)z);
        
        list result = [region, x, y, z];
        
        // Libération avant retour
        parts = [];
        return result;
    }
    else {
        Debug("Invalid SLurl format - not enough parts");
        // Libération avant retour
        parts = [];
        return [];
    }
}

//----------------------------------------
// SCAN AVATAR AVEC GETOBJECTDATA - VERSION CORRIGÉE
//----------------------------------------
ScanAvatarWithCorrade(key targetKey) {
    // Vérification automatique de la mémoire
    CheckMemoryUsage();
    
    g_kTarget = targetKey;
    
    if(g_kUserID == NULL_KEY) {
        g_kUserID = llGetOwner();
    }
    
    // COMMANDE CORRIGÉE : Utiliser getobjectdata au lieu de getwearables
    list cmdParams = [
        "command", "getobjectdata",
        "group", CORRADE_GROUP,
        "password", CORRADE_PASS,
        "agent", (string)targetKey,
        "data", "AttachedTo,Name"  // Récupérer les attachements et leurs noms
    ];
    
    string cmd = wasKeyValueEncode(cmdParams);
    
    // Libération sécurisée
    cmdParams = [];
    
    g_sLastCommand = "getobjectdata";
    g_iScanAttempts++;
    
    Debug("Scan attempt #" + (string)g_iScanAttempts + " for avatar: " + llKey2Name(targetKey));
    Debug("Using getobjectdata command for attachments");
    llInstantMessage(g_kUserID, "[GuardGender] Scanning avatar attachments... (attempt " + (string)g_iScanAttempts + ")");
    
    // Requête HTTP avec timeout approprié
    g_kRequestID = llHTTPRequest(CORRADE_URL, [
        HTTP_METHOD, "POST", 
        HTTP_MIMETYPE, "application/x-www-form-urlencoded",
        HTTP_VERBOSE_THROTTLE, FALSE,
        HTTP_VERIFY_CERT, FALSE
    ], cmd);
}

//----------------------------------------
// FONCTION CORRIGÉE : TELEPORTER BOT VERS LE PORTEUR
//----------------------------------------
TeleportBotToWearer() {
    // Vérification automatique de la mémoire
    CheckMemoryUsage();
    
    g_iBotTeleporting = TRUE;
    g_iScanAttempts = 0;
    
    // Obtenir la position du porteur/propriétaire
    key owner = llGetOwner();
    list ownerDetails = llGetObjectDetails(owner, [OBJECT_POS, OBJECT_ROT]);
    vector ownerPos = llList2Vector(ownerDetails, 0);
    
    // Libération immédiate
    ownerDetails = [];
    
    // Ajuster la position pour éviter les collisions
    ownerPos.z += 2.0; // Placer le bot légèrement au-dessus
    
    // FORMAT CORRIGÉ : sans < >
    string positionString = (string)ownerPos.x + "," + (string)ownerPos.y + "," + (string)ownerPos.z;
    
    list cmdParams = [
        "command", "teleport",
        "group", CORRADE_GROUP,
        "password", CORRADE_PASS,
        "entity", "region",
        "region", llGetRegionName(),
        "position", positionString
    ];
    
    string cmd = wasKeyValueEncode(cmdParams);
    
    // Libération sécurisée
    cmdParams = [];
    
    g_sLastCommand = "teleport_to_wearer";
    
    Debug("Teleporting bot to wearer position: " + positionString + " in region " + llGetRegionName());
    if(g_kUserID != NULL_KEY) {
        llInstantMessage(g_kUserID, "[GuardGender] Teleporting bot to your location...");
    }
    
    g_kRequestID = llHTTPRequest(CORRADE_URL, [
        HTTP_METHOD, "POST", 
        HTTP_MIMETYPE, "application/x-www-form-urlencoded",
        HTTP_VERBOSE_THROTTLE, FALSE,
        HTTP_VERIFY_CERT, FALSE
    ], cmd);
}

//----------------------------------------
// FONCTION MODIFIÉE : INITIER LE SCAN D'UN AVATAR
//----------------------------------------
InitiateScan(key targetKey, key userKey) {
    g_kTarget = targetKey;
    g_kUserID = userKey;
    g_iScanAttempts = 0;
    g_iWaitingForStabilization = FALSE;
    
    Debug("Initiating scan for avatar: " + llKey2Name(targetKey));
    
    // Étape 1: Téléporter le bot vers le porteur
    TeleportBotToWearer();
}

//----------------------------------------
// UI HELPERS
//----------------------------------------
CleanListen() {
    if(g_iMenuListen) {
        llListenRemove(g_iMenuListen);
        g_iMenuListen = 0;
    }
    if(g_iMenuHandle) {
        llSetTimerEvent(0.0);
        g_iMenuHandle = 0;
    }
}

ReturnToAppsMenu(key av) {
    Debug("Returning to Apps menu");
    llMessageLinked(LINK_ROOT, CMD_OWNER, "menu Apps", av);
}

ShowGuardGenderMenu(key av) {
    Debug("ShowGuardGenderMenu called for avatar: " + (string)av);
    CleanListen();
    g_kUserID = av;
    
    g_iCurrentPage = 0;
    g_sCurrentMenu = "main";
    
    g_iMenuChan = -1 - (integer)llFrand(1000000000.0);
    g_iMenuListen = llListen(g_iMenuChan, "", av, "");
    
    string guardianStatus;
    if(g_iGuardianActive) {
        guardianStatus = "ON";
    }
    else {
        guardianStatus = "OFF";
    }
    
    string guardianButton;
    if(g_iGuardianActive) {
        guardianButton = "Guardian OFF";
    }
    else {
        guardianButton = "Guardian ON";
    }
    
    string returnHomeButton;
    if(g_iSendHomeAfterScan) {
        returnHomeButton = "Auto-Return OFF";
    }
    else {
        returnHomeButton = "Auto-Return ON";
    }
    
    string autoReturnStatus;
    if(g_iSendHomeAfterScan) {
        autoReturnStatus = "ON";
    }
    else {
        autoReturnStatus = "OFF";
    }
    
    llDialog(av,
        "[GuardGender]\n\n• BotGuardian: Use the bot to scan attachments\n• Guardian: " + guardianStatus + "\n• Auto-Return: " + autoReturnStatus + "\n• Debug: Toggle debug messages",
        ["BotGuardian", guardianButton, returnHomeButton, "Debug", "Config", "BACK to Apps"], g_iMenuChan);
    
    g_iMenuHandle = 1;
    llSetTimerEvent(DIALOG_TIMEOUT);
    Debug("GuardGender menu displayed on channel: " + (string)g_iMenuChan);
}

ShowDebugMenu(key av) {
    Debug("ShowDebugMenu called for avatar: " + (string)av);
    CleanListen();
    g_kUserID = av;
    g_sCurrentMenu = "debug";
    
    g_iMenuChan = -1 - (integer)llFrand(1000000000.0);
    g_iMenuListen = llListen(g_iMenuChan, "", av, "");
    
    string debugStatus;
    if(g_iDebug) {
        debugStatus = "ON";
    }
    else {
        debugStatus = "OFF";
    }
    
    string debugButton;
    if(g_iDebug) {
        debugButton = "Debug OFF";
    }
    else {
        debugButton = "Debug ON";
    }
    
    llDialog(av,
        "[Debug Settings]\n\n• Debug Messages: " + debugStatus,
        [debugButton, "BACK to Gender"], g_iMenuChan);
    
    g_iMenuHandle = 1;
    llSetTimerEvent(DIALOG_TIMEOUT);
    Debug("Debug menu displayed on channel: " + (string)g_iMenuChan);
}

ShowBotGuardianMenu(key av) {
    Debug("ShowBotGuardianMenu called for avatar: " + (string)av);
    CleanListen();
    g_kUserID = av;
    g_sCurrentMenu = "botguardian";
    
    g_iMenuChan = -1 - (integer)llFrand(1000000000.0);
    g_iMenuListen = llListen(g_iMenuChan, "", av, "");
    
    llDialog(av,
        "[BotGuardian]\n\n• Analyze Target: Enter UUID\n• Scan: Choose a nearby avatar\n• Test Bot: Verify connection\n• Send Home: Return bot to home region",
        ["Analyze Target", "Scan", "Test Bot", "Send Home", "BACK to Gender"], g_iMenuChan);
    
    g_iMenuHandle = 1;
    llSetTimerEvent(DIALOG_TIMEOUT);
    Debug("BotGuardian menu displayed on channel: " + (string)g_iMenuChan);
}

ShowConfigMenu(key av) {
    Debug("ShowConfigMenu called for avatar: " + (string)av);
    CleanListen();
    g_kUserID = av;
    g_sCurrentMenu = "config";
    g_iConfiguring = FALSE;
    
    g_iMenuChan = -1 - (integer)llFrand(1000000000.0);
    g_iMenuListen = llListen(g_iMenuChan, "", av, "");
    
    list homeDetails = ParseSLurl(HOME_URL);
    string homeRegion;
    if(llGetListLength(homeDetails) >= 1) {
        homeRegion = llList2String(homeDetails, 0);
    }
    else {
        homeRegion = "Not Set";
    }
    
    llDialog(av,
        "[Bot Configuration]\n\n• Bot: " + CORRADE_BOTNAME + "\n• Login: " + CORRADE_USERNAME + "\n• Group: " + CORRADE_GROUP + "\n• Home: " + homeRegion,
        ["Set Login", "Set Group", "Set Pass", "Set Home", "BACK to Gender"], g_iMenuChan);
    
    g_iMenuHandle = 1;
    llSetTimerEvent(DIALOG_TIMEOUT);
    Debug("Config menu displayed on channel: " + (string)g_iMenuChan);
    
    // Libération sécurisée après utilisation
    homeDetails = [];
}

ShowConfigTextbox(key av, string item) {
    Debug("ShowConfigTextbox called for: " + item);
    CleanListen();
    g_kUserID = av;
    g_iConfiguring = TRUE;
    g_sConfigItem = item;
    g_sCurrentMenu = "configtext";
    
    g_iMenuChan = -1 - (integer)llFrand(1000000000.0);
    g_iMenuListen = llListen(g_iMenuChan, "", av, "");
    
    string currentValue = "";
    string prompt = "";
    
    if(item == "login") {
        currentValue = CORRADE_USERNAME;
        prompt = "Login Username";
    }
    else if(item == "group") {
        currentValue = CORRADE_GROUP;
        prompt = "Group Name";
    }
    else if(item == "pass") {
        currentValue = "********";
        prompt = "Group Password";
    }
    else if(item == "home") {
        currentValue = HOME_URL;
        prompt = "Home SLurl (http://maps.secondlife.com/secondlife/RegionName/X/Y/Z)";
    }
    
    llTextBox(av, prompt + "\n(currently: " + currentValue + ")\n\nEnter new value:", g_iMenuChan);
    g_iMenuHandle = 1;
    llSetTimerEvent(DIALOG_TIMEOUT);
}

ShowScanMenu(key av) {
    Debug("ShowScanMenu called for avatar: " + (string)av);
    CleanListen();
    g_kUserID = av;
    g_sCurrentMenu = "scan";
    
    // Ne charger les avatars que si nécessaire (page 0 ou liste vide)
    if(g_iCurrentPage == 0 || llGetListLength(g_lTargetKeys) == 0) {
        // Vider la liste actuelle pour libérer de la mémoire
        g_lTargetKeys = [];
        
        // Récupérer d'abord les avatars de la parcelle
        list agents = llGetAgentList(AGENT_LIST_PARCEL, []);
        Debug("Found " + (string)llGetListLength(agents) + " agents in parcel");
        
        // Si la parcelle est vide, récupérer les avatars de la région
        if(llGetListLength(agents) < 1) {
            agents = llGetAgentList(AGENT_LIST_REGION, []);
            Debug("Found " + (string)llGetListLength(agents) + " agents in region");
        }
        
        // Sécuriser la liste d'agents
        agents = SecureList(agents, "agent_list");
        
        // Filtrer les avatars
        integer i;
        integer agentCount = llGetListLength(agents);
        for(i=0; i<agentCount; ++i) {
            key k = llList2Key(agents, i);
            if(k != llGetOwner()) { // Exclure le propriétaire
                string name = llKey2Name(k);
                if(name != "") {
                    g_lTargetKeys += [k];
                    
                    // Sécurité : limiter le nombre d'avatars
                    if(llGetListLength(g_lTargetKeys) >= MAX_LIST_SIZE) {
                        Debug("WARNING: Target keys list reached maximum size, stopping");
                        break;
                    }
                }
            }
        }
        
        // Libération sécurisée de la liste temporaire
        agents = [];
    }
    
    // Si pas d'avatars, sortir
    if(llGetListLength(g_lTargetKeys) < 1) { 
        llInstantMessage(av, "[GuardGender] No avatars nearby.");
        Debug("No avatars found nearby");
        return;
    }
    
    // Calcul des pages
    integer totalPages = (llGetListLength(g_lTargetKeys) + AVATARS_PER_PAGE - 1) / AVATARS_PER_PAGE;
    
    // Normalisation de la page actuelle
    if(g_iCurrentPage >= totalPages) {
        g_iCurrentPage = 0;
    }
    if(g_iCurrentPage < 0) {
        g_iCurrentPage = totalPages - 1;
    }
    
    // Calcul des indices pour la page actuelle
    integer startIdx = g_iCurrentPage * AVATARS_PER_PAGE;
    integer endIdx = startIdx + AVATARS_PER_PAGE - 1;
    if(endIdx >= llGetListLength(g_lTargetKeys)) {
        endIdx = llGetListLength(g_lTargetKeys) - 1;
    }
    
    // Construction des boutons pour les avatars
    list buttons = [];
    integer i;
    for(i = startIdx; i <= endIdx; ++i) {
        key k = llList2Key(g_lTargetKeys, i);
        string name = llKey2Name(k);
        string buttonLabel = TruncateName(name, MAX_BUTTON_LEN);
        buttons += [buttonLabel];
    }
    
    // Sécuriser la liste de boutons
    buttons = SecureList(buttons, "scan_buttons");
    
    // Ajout des boutons de navigation
    list navButtons = [];
    if(totalPages > 1) {
        navButtons += ["Prev", "Next"];
    }
    navButtons += ["BACK to Guard"];
    
    // Configuration de l'écoute
    g_iMenuChan = -1 - (integer)llFrand(1000000000.0);
    g_iMenuListen = llListen(g_iMenuChan, "", av, "");
    
    // Affichage du dialogue
    string pageInfo = "\nPage " + (string)(g_iCurrentPage + 1) + "/" + (string)totalPages;
    llDialog(av, "Choose target:" + pageInfo, buttons + navButtons, g_iMenuChan);
    g_iMenuHandle = 1;
    llSetTimerEvent(DIALOG_TIMEOUT);
    
    Debug("Scan dialog displayed on channel: " + (string)g_iMenuChan + " page " + (string)(g_iCurrentPage + 1) + "/" + (string)totalPages);
    
    // Libération sécurisée
    buttons = [];
    navButtons = [];
}

ShowUUIDInput(key av) {
    Debug("ShowUUIDInput called for avatar: " + (string)av);
    CleanListen();
    g_kUserID = av;
    g_sCurrentMenu = "uuid";
    
    g_iMenuChan = -1 - (integer)llFrand(1000000000.0);
    g_iMenuListen = llListen(g_iMenuChan, "", av, "");
    
    llTextBox(av, "Enter the UUID of the target to analyze:", g_iMenuChan);
    g_iMenuHandle = 1;
    llSetTimerEvent(DIALOG_TIMEOUT);
}

//----------------------------------------
// CORRADE HELPERS
//----------------------------------------
TestCorradeConnection(key av) {
    Debug("Testing Corrade connection");
    g_iTestingBot = TRUE;
    g_kUserID = av;
    g_sLastCommand = "version";
    
    llInstantMessage(av, "[GuardGender] Testing Corrade bot connection...");
    
    list cmdParams = [
        "command", "version",
        "group", CORRADE_GROUP,
        "password", CORRADE_PASS
    ];
    
    string cmd = wasKeyValueEncode(cmdParams);
    
    // Libération sécurisée
    cmdParams = [];
    
    g_kRequestID = llHTTPRequest(CORRADE_URL, [
        HTTP_METHOD, "POST", 
        HTTP_MIMETYPE, "application/x-www-form-urlencoded",
        HTTP_VERBOSE_THROTTLE, FALSE,
        HTTP_VERIFY_CERT, FALSE
    ], cmd);
}

//----------------------------------------
// FONCTION TOTALEMENT CORRIGÉE : SEND HOME AVEC DEBUGGING COMPLET
//----------------------------------------
CorradeSendHome(key av) {
    Debug("CorradeSendHome called with HOME_URL: " + HOME_URL);
    
    list homeDetails = ParseSLurl(HOME_URL);
    Debug("ParseSLurl returned " + (string)llGetListLength(homeDetails) + " elements");
    
    if(llGetListLength(homeDetails) >= 4) {
        string region = llList2String(homeDetails, 0);
        float x = llList2Float(homeDetails, 1);
        float y = llList2Float(homeDetails, 2);
        float z = llList2Float(homeDetails, 3);
        
        Debug("Parsed coordinates - Region: '" + region + "', X: " + (string)x + ", Y: " + (string)y + ", Z: " + (string)z);
        
        // ESSAYER PLUSIEURS FORMATS DE TÉLÉPORTATION
        // Format 1: entity="region" avec region et position séparées
        list cmdParams = [
            "command", "teleport",
            "group", CORRADE_GROUP,
            "password", CORRADE_PASS,
            "entity", "region",
            "region", region,
            "position", (string)x + "," + (string)y + "," + (string)z
        ];
        
        string cmd = wasKeyValueEncode(cmdParams);
        
        // Libération sécurisée
        cmdParams = [];
        
        g_sLastCommand = "gohome";
        Debug("Sending teleport command to region: '" + region + "' at position: " + (string)x + "," + (string)y + "," + (string)z);
        Debug("Full command string: " + cmd);
        
        g_kUserID = av;
        g_kRequestID = llHTTPRequest(CORRADE_URL, [
            HTTP_METHOD, "POST", 
            HTTP_MIMETYPE, "application/x-www-form-urlencoded",
            HTTP_VERBOSE_THROTTLE, FALSE,
            HTTP_VERIFY_CERT, FALSE
        ], cmd);
        
        if(av != NULL_KEY) {
            llInstantMessage(av, "[GuardGender] Sending bot to: " + region + " (" + (string)x + "," + (string)y + "," + (string)z + ")");
        }
    }
    else {
        Debug("ParseSLurl failed - invalid format");
        llInstantMessage(av, "[GuardGender] Invalid home URL format. Please set a valid SLurl like: http://maps.secondlife.com/secondlife/RegionName/X/Y/Z");
    }
    
    // Libération sécurisée
    homeDetails = [];
}

//----------------------------------------
// FONCTION ALTERNATIVE SEND HOME (pour tester si la première ne marche pas)
//----------------------------------------
CorradeSendHomeAlternative(key av) {
    Debug("Trying alternative send home method");
    
    list homeDetails = ParseSLurl(HOME_URL);
    
    if(llGetListLength(homeDetails) >= 4) {
        string region = llList2String(homeDetails, 0);
        float x = llList2Float(homeDetails, 1);
        float y = llList2Float(homeDetails, 2);
        float z = llList2Float(homeDetails, 3);
        
        // Format alternatif: entity="global" (nécessite conversion en coordonnées globales)
        // Pour le moment, on teste avec le format SLurl direct
        list cmdParams = [
            "command", "teleport",
            "group", CORRADE_GROUP,
            "password", CORRADE_PASS,
            "entity", "location",
            "location", region + "/" + (string)((integer)x) + "/" + (string)((integer)y) + "/" + (string)((integer)z)
        ];
        
        string cmd = wasKeyValueEncode(cmdParams);
        
        // Libération sécurisée
        cmdParams = [];
        
        g_sLastCommand = "gohome_alt";
        Debug("Alternative teleport command: " + cmd);
        
        g_kUserID = av;
        g_kRequestID = llHTTPRequest(CORRADE_URL, [
            HTTP_METHOD, "POST", 
            HTTP_MIMETYPE, "application/x-www-form-urlencoded",
            HTTP_VERBOSE_THROTTLE, FALSE,
            HTTP_VERIFY_CERT, FALSE
        ], cmd);
    }
    else {
        llInstantMessage(av, "[GuardGender] Invalid home URL format.");
    }
    
    // Libération sécurisée
    homeDetails = [];
}

//----------------------------------------
// MAIN STATE
//----------------------------------------
default {
    state_entry() {
        // Initialisation avec nettoyage mémoire
        g_iMenuChan = 0;
        g_iMenuListen = 0;
        g_iMenuHandle = 0;
        g_kTarget = NULL_KEY;
        g_kRequestID = NULL_KEY;
        g_kUserID = NULL_KEY;
        g_lTargetKeys = [];
        g_iTestingBot = FALSE;
        g_iConfiguring = FALSE;
        g_sConfigItem = "";
        g_iGuardianActive = FALSE;
        g_iCurrentPage = 0;
        g_sCurrentMenu = "";
        g_sLastCommand = "";
        g_iSendHomeAfterScan = TRUE;
        g_iScanAttempts = 0;
        g_iBotTeleporting = FALSE;
        g_iWaitingForStabilization = FALSE;
        
        // Initialiser les listes vides pour économiser la mémoire
        FEMALE_BODY_KEYWORDS = [];
        MALE_BODY_KEYWORDS = [];
        
        // Initialiser le timer de nettoyage mémoire
        LAST_MEMORY_CLEANUP = llGetTime();
        
        Debug("Registering GuardGender menu with OpenCollar");
        llMessageLinked(LINK_SET, MENUNAME_RESPONSE, PARENT_MENU + "|" + MAIN_MENU, "");
        
        llMessageLinked(LINK_SET, MENUNAME_REMOVE, PARENT_MENU + "|SPY", "");
        llMessageLinked(LINK_ROOT, MENUNAME_REMOVE, PARENT_MENU + "|SPY", "");
        llMessageLinked(LINK_ROOT, MENUNAME_REMOVE, "Apps|SPY", "");
        
        llMessageLinked(LINK_SET, LM_SETTING_REQUEST, "spy_", "");
        
        llSetTimerEvent(2.0);
    }
    
    // TIMER MODIFIÉ POUR GÉRER LA STABILISATION + NETTOYAGE MÉMOIRE
    timer() {
        if(llGetTime() < 3.0) {
            llMessageLinked(LINK_SET, MENUNAME_RESPONSE, PARENT_MENU + "|" + MAIN_MENU, "");
            
            llMessageLinked(LINK_SET, MENUNAME_REMOVE, PARENT_MENU + "|SPY", "");
            llMessageLinked(LINK_ROOT, MENUNAME_REMOVE, PARENT_MENU + "|SPY", "");
            llMessageLinked(LINK_ROOT, MENUNAME_REMOVE, "Apps|SPY", "");
            return;
        }
        
        // Vérification automatique de la mémoire
        CheckMemoryUsage();
        
        if(g_iMenuHandle) {
            Debug("Dialog timeout");
            CleanListen();
            if(g_kUserID != NULL_KEY) {
                llInstantMessage(g_kUserID, "[GuardGender] Time expired for command. Please try again.");
                g_kUserID = NULL_KEY;
            }
            llSetTimerEvent(0.0);
        }
        else if(g_iWaitingForStabilization) {
            // Le bot s'est stabilisé, procéder au scan
            Debug("Bot stabilization period completed, proceeding with scan");
            g_iWaitingForStabilization = FALSE;
            llSetTimerEvent(0.0);
            
            if(g_kTarget != NULL_KEY && g_kUserID != NULL_KEY) {
                llInstantMessage(g_kUserID, "[GuardGender] Bot stabilized, scanning target...");
                ScanAvatarWithCorrade(g_kTarget);
            }
        }
        else {
            llSetTimerEvent(0.0);
        }
    }
    
    // Gestionnaire HTTP amélioré avec gestion du délai de stabilisation + sécurité mémoire
    http_response(key request_id, integer status, list metadata, string body) {
        if(request_id != g_kRequestID) return;
        
        // Sécuriser le body de la réponse
        body = SecureString(body, "http_response_body");
        
        Debug("HTTP Response - Status: " + (string)status + ", Command: " + g_sLastCommand);
        Debug("Response body preview: " + llGetSubString(body, 0, 200) + "...");
        
        // Vérifier le statut HTTP
        if(status != 200) {
            string errorMsg = "HTTP Error " + (string)status;
            if(status == 404) errorMsg += " - Corrade not found at URL";
            else if(status == 500) errorMsg += " - Corrade server error";
            else if(status == 408) errorMsg += " - Request timeout";
            
            Debug("HTTP Error: " + errorMsg);
            if(g_kUserID != NULL_KEY) {
                llInstantMessage(g_kUserID, "[GuardGender] " + errorMsg);
            }
            
            // Retry logic pour getobjectdata
            if(g_sLastCommand == "getobjectdata" && g_iScanAttempts < g_iMaxRetries) {
                Debug("Retrying getobjectdata command...");
                llSetTimerEvent(SCAN_RETRY_DELAY);
                return;
            }
            
            g_kRequestID = NULL_KEY;
            g_iBotTeleporting = FALSE;
            g_iWaitingForStabilization = FALSE;
            return;
        }
        
        // Traitement spécifique selon la commande
        if(g_sLastCommand == "version") {
            string success = GetValueFromResponse(body, "success");
            if(success == "True" || success == "true") {
                string version = GetValueFromResponse(body, "data");
                llInstantMessage(g_kUserID, "[GuardGender] ✓ Bot connection successful! Version: " + version);
                Debug("Corrade version: " + version);
            }
            else {
                string error = GetValueFromResponse(body, "error");
                llInstantMessage(g_kUserID, "[GuardGender] ✗ Bot connection failed: " + error);
                Debug("Corrade connection failed: " + error);
            }
            g_iTestingBot = FALSE;
        }
        else if(g_sLastCommand == "teleport_to_wearer") {
            string success = GetValueFromResponse(body, "success");
            if(success == "True" || success == "true") {
                Debug("Bot successfully teleported to wearer location");
                if(g_kUserID != NULL_KEY) {
                    llInstantMessage(g_kUserID, "[GuardGender] ✓ Bot teleported, stabilizing...");
                }
                g_iBotTeleporting = FALSE;
                
                // DÉMARRER LE DÉLAI DE STABILISATION
                if(g_kTarget != NULL_KEY) {
                    Debug("Starting " + (string)TELEPORT_STABILIZATION_DELAY + " second stabilization delay");
                    g_iWaitingForStabilization = TRUE;
                    llSetTimerEvent(TELEPORT_STABILIZATION_DELAY);
                }
            }
            else {
                string error = GetValueFromResponse(body, "error");
                Debug("Bot teleportation to wearer failed: " + error);
                if(g_kUserID != NULL_KEY) {
                    llInstantMessage(g_kUserID, "[GuardGender] ✗ Bot teleportation failed: " + error);
                }
                g_iBotTeleporting = FALSE;
                g_iWaitingForStabilization = FALSE;
                g_kTarget = NULL_KEY; // Annuler le scan
            }
        }
        else if(g_sLastCommand == "getobjectdata") {
            string success = GetValueFromResponse(body, "success");
            if(success == "True" || success == "true") {
                list attachments = ProcessAttachmentData(body);
                
                if(llGetListLength(attachments) > 0) {
                    string gender = DetectGenderFromBody(attachments);
                    string avatarName = llKey2Name(g_kTarget);
                    
                    string genderIcon;
                    if(gender == "female") {
                        genderIcon = "♀";
                    }
                    else if(gender == "male") {
                        genderIcon = "♂";
                    }
                    else {
                        genderIcon = "?";
                    }
                    
                    string resultMsg = "[GuardGender] " + genderIcon + " " + avatarName + " - Gender: " + llToUpper(gender);
                    resultMsg += "\nAttachments found: " + (string)llGetListLength(attachments);
                    
                    llInstantMessage(g_kUserID, resultMsg);
                    Debug("Gender detection result: " + gender + " for " + avatarName);
                    
                    // Afficher quelques attachements en debug
                    if(g_iDebug && llGetListLength(attachments) > 0) {
                        string attachList = "Attachments: ";
                        integer i;
                        integer maxDisplay = llGetListLength(attachments);
                        if(maxDisplay > 5) maxDisplay = 5; // Limiter pour la mémoire
                        for(i = 0; i < maxDisplay; i++) {
                            if(i > 0) attachList += ", ";
                            attachList += llList2String(attachments, i);
                        }
                        if(llGetListLength(attachments) > 5) attachList += "...";
                        Debug(attachList);
                    }
                    
                    // Auto-return du bot si activé
                    if(g_iSendHomeAfterScan) {
                        llInstantMessage(g_kUserID, "[GuardGender] Sending bot back home...");
                        CorradeSendHome(g_kUserID);
                    }
                }
                else {
                    llInstantMessage(g_kUserID, "[GuardGender] No attachments found for " + llKey2Name(g_kTarget));
                    Debug("No attachments found in response");
                    
                    // Auto-return même s'il n'y a pas d'attachements
                    if(g_iSendHomeAfterScan) {
                        llInstantMessage(g_kUserID, "[GuardGender] Sending bot back home...");
                        CorradeSendHome(g_kUserID);
                    }
                }
                
                // Libération sécurisée de la liste d'attachments
                attachments = [];
            }
            else {
                string error = GetValueFromResponse(body, "error");
                Debug("getobjectdata command failed: " + error);
                
                // Retry logic
                if(g_iScanAttempts < g_iMaxRetries) {
                    llInstantMessage(g_kUserID, "[GuardGender] Scan failed, retrying... (" + (string)g_iScanAttempts + "/" + (string)g_iMaxRetries + ")");
                    llSetTimerEvent(SCAN_RETRY_DELAY);
                    return;
                }
                else {
                    llInstantMessage(g_kUserID, "[GuardGender] ✗ Scan failed after " + (string)g_iMaxRetries + " attempts: " + error);
                    
                    // Auto-return même en cas d'échec
                    if(g_iSendHomeAfterScan) {
                        llInstantMessage(g_kUserID, "[GuardGender] Sending bot back home...");
                        CorradeSendHome(g_kUserID);
                    }
                }
            }
            
            g_iScanAttempts = 0; // Reset counter
        }
        else if(g_sLastCommand == "gohome") {
            Debug("=== GOHOME RESPONSE ANALYSIS ===");
            Debug("Full response body: " + body);
            string success = GetValueFromResponse(body, "success");
            string error = GetValueFromResponse(body, "error");
            Debug("Extracted success: '" + success + "'");
            Debug("Extracted error: '" + error + "'");
            
            if(success == "True" || success == "true") {
                Debug("Bot successfully sent home");
                if(g_kUserID != NULL_KEY) {
                    llInstantMessage(g_kUserID, "[GuardGender] ✓ Bot returned home successfully");
                }
            }
            else {
                Debug("Send home failed - trying alternative method");
                if(g_kUserID != NULL_KEY) {
                    llInstantMessage(g_kUserID, "[GuardGender] ⚠ Primary send home failed: " + error + " - Trying alternative...");
                    // Essayer la méthode alternative automatiquement
                    CorradeSendHomeAlternative(g_kUserID);
                    return;
                }
            }
        }
        else if(g_sLastCommand == "gohome_alt") {
            Debug("=== ALTERNATIVE GOHOME RESPONSE ===");
            Debug("Full response body: " + body);
            string success = GetValueFromResponse(body, "success");
            string error = GetValueFromResponse(body, "error");
            
            if(success == "True" || success == "true") {
                Debug("Alternative send home method successful");
                if(g_kUserID != NULL_KEY) {
                    llInstantMessage(g_kUserID, "[GuardGender] ✓ Bot returned home (alternative method)");
                }
            }
            else {
                Debug("Alternative send home also failed: " + error);
                if(g_kUserID != NULL_KEY) {
                    llInstantMessage(g_kUserID, "[GuardGender] ✗ Both send home methods failed. Error: " + error);
                }
            }
        }
        
        g_kRequestID = NULL_KEY;
        
        // Nettoyer les variables de scan uniquement après un scan complet
        if(g_sLastCommand == "getobjectdata" || g_sLastCommand == "gohome" || g_sLastCommand == "gohome_alt") {
            g_kTarget = NULL_KEY;
        }
        
        // Libération finale des métadonnées
        metadata = [];
    }
    
    link_message(integer sender, integer num, string str, key id) {
        Debug("Link message: " + str);
        
        if(num == LM_SETTING_RESPONSE) {
            list params = llParseString2List(str, ["="], []);
            if(llGetListLength(params) >= 2) {
                string settingName = llList2String(params, 0);
                string settingValue = llList2String(params, 1);
                
                // Sécuriser les valeurs de configuration
                settingName = SecureString(settingName, "setting_name");
                settingValue = SecureString(settingValue, "setting_value");
                
                if(settingName == "spy_botusername") {
                    CORRADE_USERNAME = settingValue;
                }
                else if(settingName == "spy_group") {
                    CORRADE_GROUP = settingValue;
                }
                else if(settingName == "spy_homeurl") {
                    HOME_URL = settingValue;
                }
                else if(settingName == "spy_debug") {
                    g_iDebug = (integer)settingValue;
                }
                else if(settingName == "spy_guardian") {
                    g_iGuardianActive = (integer)settingValue;
                }
                else if(settingName == "spy_autoreturn") {
                    g_iSendHomeAfterScan = (integer)settingValue;
                }
            }
            
            // Libération sécurisée
            params = [];
            return;
        }
        
        if(num == MENUNAME_REQUEST) {
            if(str == PARENT_MENU) {
                llMessageLinked(sender, MENUNAME_RESPONSE, PARENT_MENU + "|" + MAIN_MENU, "");
            }
        }
        else if(str == "Apps" || str == PARENT_MENU) {
            llMessageLinked(sender, MENUNAME_RESPONSE, PARENT_MENU + "|" + MAIN_MENU, "");
        }
        else if(str == "menu " + MAIN_MENU || str == MAIN_MENU || 
                str == "menu GuardGender" || str == "guardgender" || 
                str == "MENU_" + MAIN_MENU) {
            ShowGuardGenderMenu(id);
        }
        else if(str == "menu_" + llToLower(PARENT_MENU) || str == "menu_apps") {
            llMessageLinked(sender, MENUNAME_RESPONSE, PARENT_MENU + "|" + MAIN_MENU, "");
        }
        else if(llGetSubString(str, 0, 10) == "guardgender_") {
            string cmd = llGetSubString(str, 11, -1);
            if(cmd == "menu") ShowGuardGenderMenu(id);
            else if(cmd == "botguardian") ShowBotGuardianMenu(id);
            else if(cmd == "scan") ShowScanMenu(id);
            else if(cmd == "test") TestCorradeConnection(id);
            else if(cmd == "config") ShowConfigMenu(id);
            else if(cmd == "debug") ShowDebugMenu(id);
            else if(cmd == "sendhome") CorradeSendHome(id);
            else if(cmd == "guardian") {
                g_iGuardianActive = !g_iGuardianActive;
                string activationStatus;
                if(g_iGuardianActive) {
                    activationStatus = "ACTIVATED";
                }
                else {
                    activationStatus = "DEACTIVATED";
                }
                llInstantMessage(id, "[GuardGender] Guardian is now " + activationStatus);
                llMessageLinked(LINK_SET, LM_SETTING_SAVE, "spy_guardian=" + (string)g_iGuardianActive, "");
            }
            else if(cmd == "autoreturn") {
                g_iSendHomeAfterScan = !g_iSendHomeAfterScan;
                string returnStatus;
                if(g_iSendHomeAfterScan) {
                    returnStatus = "ACTIVATED";
                }
                else {
                    returnStatus = "DEACTIVATED";
                }
                llInstantMessage(id, "[GuardGender] Auto-Return is now " + returnStatus);
                llMessageLinked(LINK_SET, LM_SETTING_SAVE, "spy_autoreturn=" + (string)g_iSendHomeAfterScan, "");
            }
        }
        else if((num >= CMD_OWNER && num <= CMD_WEARER) && 
                (str == MAIN_MENU || str == llToLower(MAIN_MENU))) {
            ShowGuardGenderMenu(id);
        }
    }
    
    listen(integer chan, string nm, key id, string msg) {
        Debug("Listen on '" + g_sCurrentMenu + "': " + msg);
        CleanListen();
        
        // Sécuriser le message reçu
        msg = SecureString(msg, "listen_message");
        
        if(g_sCurrentMenu == "main
